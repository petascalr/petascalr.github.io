Spring:

General knowledge:
	- The EJB specification is a subset of the Java EE specification
	- Spring is a replacement for EJB.
	- The EJB specification intends to provide a standard way to implement the server-side (also called "back-end") 'business' software typically 
		found in enterprise applications (as opposed to 'front-end' user interface software).
	- Primary functions: DI & AOP.
	- Spring was created as an alternative to heavy EJB.


Components: Spring Core (IOC, AOP), Spring MVC, Spring WebFlow, Spring Security, Spring Cloud (Wraps Netflix OSS)

Ch1: constructor injection, setter injection. (DI facilitates loose coupling). wiring components
	- XML-based configuration & Java-based configuration (@Configuration, @Bean).
	- based on how the configuration is done, Spring needs an application context to wire beans together.
	- ClassPathXmlApplicationContext loads the XML configuration from the CLASSPATH.
	- AnnotationConfigApplicationContext loads the Java based configuration.
	
	AOP: promotes separation of concerns in a software system. (cross-cutting concerns are: logging, transaction mgmt, security).
		- point-cuts: call that should be surrounded with advices.
		- advices: before, after, (syntax is AspectJ)
		
	Templates: Simplifies boilerplate code: eg. SimpleJdbcTemplate.
	
	Bean Factories vs App Containers. Bean factories are too low level. App Containers are preferred.
		- AnnotationConfigApplicationContext / AnnotationConfigWebApplicationContext: Java-based configuration.
		- ClassPathXmlApplicationContext—Loads a context definition from one or more XML files located in the classpath, treating context-definition files as classpath resources.
		- FileSystemXmlApplicationContext—Loads a context definition from one or more XML files in the filesystem.
		- XmlWebApplicationContext—Loads context definitions from one or more XML files contained in a web application.
			ApplicationContext context = new FileSystemXmlApplicationContext("c:/knight.xml");
			ApplicationContext context = new ClassPathXmlApplicationContext("knight.xml"); // looks for knight.xml in CLASSPATH (including in JAR files).
			
	Lifecycle of a Bean in Spring: if a bean implements various interfaces, various bean lifecycle steps can be customized.
	
	- Spring Core container (used by all other spring modules)
	
Ch2: Beans Wiring
	- Spring configurations can be mixed for the same project (XMLConfig, JavaConfig, AutoConfig). Automatic configuration is recommended. 
		JavaConfig is recommended if we don't maintain the source code. XML is the least recommended one.
	- Automatic wiring: beans are marked with @Component.
		- Automatic component scanning is not enabled by default. Enable it with @Configuration, @ComponentScan on the Spring config class.
		- Spring supports @Named annotation as an alternative to @Component.
		- @ComponentScan with no argument scans automatically in its package. Setting a different base package: 
			@Configuration, @ComponentScan(basePackages="soundsystem"). Also works with classes @ComponentScan(basePackageClasses={CDPlayer.class, DVDPlayer.class})
		- Setters or constructors are marked with @Autowired. Spring will try to auto-resolve them. If it fails, Spring will throw an exception. 
			Properties cand be marked @Autowired(required=false), so that Spring doesnt throw.
		- Java DI Specifications uses @Inject (equivalent to @Autowired), and @Named (eq. to @Component)
	
	- JavaConfig wiring (used for instance when you want to wire beans from external library whose source you don't maintain)
		- usually it is placed in a separate package, so it is kept apart from the business logic.
		- JavaConfig class is marked with @Configuration.
		- inside the JavaConfig class, create a method marked with @Bean for each bean you want constructed. (Or specify name: @Bean(name="lonelyHeartsClubBand")).
		- each method constructing a bean (marked with @Bean) is called only once (the bean is constructed only once). Further calls are intercepted, and the same instance is returned.
			- *** By default, all beans in Spring are singletons ***

	- XML wiring: the least used method (also this was the first method used in Spring).
		- XML configuration does not benefit from the compile-time verification of names (if you rename a class, you must also update xml config).
		- validity of the XML config can be checked using pring Tool Suite (an Eclipse extension).
		- beans in XML represent instances, not classes. By default each bean is instantiated only once (singleton).
		- constructors can be injected with literal values specified in XML, or collections (List - <list> tag in XML, or <set> tag)
		- constructor injection is usually used for hard dependencies, and setter injection for optional deps.

	- annotations are defined in import org.springframework.beans.factory.annotation.Autowired;
	- You're free to mix component scanning and autowiring with JavaConfig and/or XML configuration.
		- Referencing XML config from JavaConfig:
			@Import annotation: mixes multiple JavaConfig classes together:
				@Import({CDPlayerConfig.class, CDConfig.class})
				public class SoundSystemConfig { }

			@ImportResource: from a JavaConfig class, import beans declared in an XML configuration.
				@Configuration
				@Import(CDPlayerConfig.class)
				@ImportResource("classpath:cd-config.xml")
				public class SoundSystemConfig {}
		- Referencing from XML config
			1. other XML config: <import resource="other-xml-config.xml">
			2. Other Java config: <bean class="JavaConfig.class"> (declare it as a bean).
		- best approach is to have a root configuration (either JavaConfig or XML) that imports all other configurations.
		
	Tags: @Component (or @Named), @Configuration, @ComponentScan, @Bean, @Autowired (or @Inject), @Import, @ImportResource
		@Qualifier: used in order to remove injection confusion (Qualifier allows you to associate a name for a bean, 
			and at injection point specify the name as well, when multiple beans can be injected).
	
Ch4: Aspect-Oriented Programming (AOP)
	- In software development, functions that span multiple points of an application are called cross-cutting concerns.
	- Aspects terminology: Advice (the job of an aspect), Pointcut
		- Advices: Before, After, After-returning, after-throwing, Around.
		- "Join point" is a point in the execution of the application where an aspect can be plugged in. 
			This point could be a method being called, an exception being thrown, or even a field being modified.
		- Pointcuts: the "where" of an aspect: The pointcut defines where (at what join points) that advice is applied.
		- An aspect is the merger of advice and pointcuts.
	- Spring aspects are implemented as proxies that wrap the target object. The proxy handles method calls, performs additional aspect logic, 
		and then invokes the target method. (Spring AOP implementation only works on method join points).
	- Spring uses AspectJ notation for defining aspects/pointcuts.
	- An aspect (a class annotated with @Aspect) can also be a bean.
	- AOP is not enabled by default. It can be enabled in JavaConfig with @EnableAspectJAutoProxy (near @ComponentScan), or with <aop:aspectj-autoproxy> in XMLConfig.
	- Even if Spring uses AspectJ annotations for AOP, it is limited to Proxy-based AOP (only for methods).
	- @Around advice: combines both @Before and @After advices (in the handler method you need to call jp.proceed() to execute the wrapped method, 
		then do your "@After" advice)
	
	Annotations: @Aspect; @Pointcut: define the pointcut inside an aspect. Further pointcuts can refer this one (to prevent code duplication)
		marking pointcuts: @Before, @After, @Around, @AfterReturning, @AfterThrowing.
	
Ch5: Building Spring Web Applications (Spring MVC)
	MVC: Servlet is the Controller, JSP is the View.
	- Like most MVC frameworks, Spring MVC funnels requests through a single front controller servlet (DispatcherServlet).
	- A MVC may have multiple Controllers, so the DispatcherServlet needs to know whick controller to use, so it consults the 
		HandlerMapper (decision is based on the Request URL).
	- The logic performed by a controller often results in some information that needs to be carried back to the user and displayed in the browser. 
		This information is referred to as the Model (Model is the business-logic part).
	
	Controller: Selects the Model and the View (based on the Request params)
	Model: business logic (it takes the information from the Request and produces new information)
	View: It takes the information produced by the Model and presents it in HTML (JSP).
	DispatcherServlet -> Handler Mapping -> Controller -> Model and logical View name -> View Resolver -> View.
	- Any class that extends AbstractAnnotationConfigDispatcherServletInitializer will automatically be used to configure 
		DispatcherServlet and the Spring application context in the application’s servlet context.
	- In Spring MVC, controllers are just classes (annotated with @Controller) with methods that are annotated with @RequestMapping to declare 
		the kind of requests they’ll handle.
	- The method annotated with RequestMapping just returns the name of the view that renders the view.
	
	Annotations: @Controller (alias for @Component), @RequestMapping("/url"), @RequestParam, @RestController
	
Ch6: Rendering web views.
	- View Resolving (map view name returned by controller to an actual jsp): InternalResourceViewResolver. It was configured to apply a 
		prefix of /WEB-INF/views/ and a suffix of .jsp to a view name.
	- public interface ViewResolver { View resolveViewName(String viewName, Locale locale) throws Exception; }
	- public interface View { String getContentType(); void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) throws Exception; }
	- Spring provides several implementations for these interfaces, like: InternalResourceViewResolver (for JSP), ResourceBundleViewResolver, 
		TilesViewResolver (Apache Tiles views), etc.
	- Thymeleaf is a compelling alternative to JSP that offers a view resolver for working with Thymeleaf’s natural templates: templates that have 
		more in common with the HTML they produce than with the Java code that drives them, but JSP is still the dominant View technology for Java.
	- JSP is a specification that’s tightly coupled to the servlet specification. This means it can only be used for web views in a servlet-based web application.
	
Ch7: Spring Web Flow: Spring Web Flow is an extension to Spring MVC that enables development of flowbased web applications.
	- Spring Web Flow is a web framework that enables the development of elements following a prescribed flow. (like an online shopping cart steps until final payment.) 
	- Spring Web flow can only be configured in XMLConfig.
	- We have: transitions, states
	
Ch9: Spring Security: Introducing Spring Security / Securing web applications using servlet filters / Authentication against databases and LDAP
	- Spring Security, a security framework implemented with Spring AOP and servlet filters.
	- Spring Security provides a comprehensive security solution, handling authentication and authorization at both the web request method invocation level.
	- To secure web requests and restrict access at the URL level, Spring Security uses servlet filters.
	- Spring Security can also secure method invocations using Spring AOP, proxying objects and applying advice to ensure that the user has the proper authority to invoke secured methods.
	- Can be enabled with @EnableWebSecurity, along with @Configuration, for the class extending WebSecurityConfigurerAdapter.
	- Spring Security can connect to user stores like LDAP, in-memory, to grab users and their permissions.
	- Defines Roles & Authorities. Each Role has one or more Authorities. same authority can be assigned to multiple Roles.
	
Ch10: Hitting the database with Spring and JDBC. (Spring Data)
	- JDBC throws SQLException for all kinds of DB problems (connectivity, query syntax error, schema errors, etc). Hard to debug. 
		Hibernate offers a lot of exceptions (for any error), but they are specific to Hibernate (they should not be treated by user code).
	- All Spring Data exceptions are rooted with DataAccessException (unchecked). Instead of forcing developers to write catch blocks 
		(which are often left empty), Spring promotes the use of unchecked exceptions.
	- To take advantage of Spring’s data-access exceptions, you must use one of Spring’s supported data-access templates.
	- Spring Data access templates: Spring separates the fixed and variable parts of the data-access process into two distinct classes: 
		templates and callbacks. Templates manage the fixed part of the process, whereas your custom data-access code is handled in callbacks.
	- Spring comes with several templates to choose from, depending on your persistence platform choice. JdbcTemplate, HibernateTemplate or JpaTemplate
	- Spring can use a JDBC driver-based data source, configured either in XML or in JavaConfig.
	- Spring JDBC templates (eliminates the boilerplate JDBC code: connection, resource free-up, etc): JdbcTemplate, NamedParameterJdbcTemplate, 
		SimpleJdbcTemplate. Every JDBC template from spring needs a DataSource to function, that can be injected by means of spring.
	
Ch11: Learning Spring data access philosophy
	- Lazy loading: as object graphs become more complex, you sometimes don’t want to fetch entire relationships immediately. 
		Lazy loading allows you to grab data only as it’s needed.
	- Eager fetching: this is the opposite of lazy loading. Eager fetching allows you to grab an entire object graph in one query.
	- Cascading: sometimes changes to a database table should result in changes to other tables as well. Going back to the purchase order example, 
		when an Order object is deleted, you also want to delete the associated LineItems. from the database.
	- Hibernate: The Session interface provides basic data-access functionality such as the ability to save, update, delete, and load objects 
		from the database. (created from SessionFactory).
	- Hibernate: defining your object-to-database mapping in XML or using annotations is possible (based on Hibernate version).
	
Ch21: Simplifying development with Spring Boot.
	- Spring Boot starters—Spring Boot starters aggregate common groupings of dependencies into single dependencies that can be added 
		to a project’s Maven or Gradle build. (spring starter dependencies are always compatible with each other).
	- Spring Boot Actuator: it adds several urls to SpringBoot applications to allow the user to get more insight on the app. ( /autoconfig, /beans).
	
	
Spring Profiles: @Profile annotation.
	Allows you to map each bean from a spring container to a specific profile, like dev, debug, production, testing etc. 
		When we deploy the application in production, only beans with production profile will be initialized, and the rest discarded.
	- Any bean that does not specify any profile is by default assigned to the default profile.
	- in tests, the active profile can be changed with @ActiveProfile.
	
Summary:
	Beans can be defined with the following stereotype annotations: @Component, @Controller, @Service, @Repository.
		List of beans in SpringBoot can be optained throuigh the actuator, at http://<IP>/beans.
	Bean scope: Can be defined with the @Scope annotation. By default they are singleton. All scopes: 
		* singleton: Scopes a single bean definition to a single object instance per Spring IoC container.
		* prototype: Scopes a single bean definition to any number of object instances. (Any injected instance is different).
		* request: Scopes a single bean definition to the lifecycle of a single HTTP request; that is, each HTTP request has its own instance of a bean created 
			off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext.
		* session: Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext.
		* global-session: Scopes a single bean definition to the lifecycle of a global HTTP Session. Typically only valid when used in a portlet context. 
			Only valid in the context of a web-aware Spring ApplicationContext.
	@Configuration: marks a class as JavaConfig class.
	@Bean: a method inside a @Configuration class that returns a bean (constructs a bean)
	@Autowired: automatic injection of beans marked with either @Component, @Service, @Repository, @Controller.
	@EnableWebSecurity: is used along with @Configuration annotation to enable Spring Security.
	@SpringBootApplication, @EnableAutoConfiguration
	@Transactional: Spring declarative transaction management implemented using AOP. Basically creates a proxy method/class around the user 
		method/class marked with @Transactional, and before the method it starts a transaction (with TransactionInterceptor from Spring), and after the user
		method returns, it commits/rolls-back the transaction, based on result. 
	