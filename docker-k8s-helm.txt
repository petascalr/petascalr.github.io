===== Docker =====

	Ch1: Introduction
	Container = Sandbox = "Jail"
	Docker is NOT a virtualization technology. Instead, it helps you use the container technology already built into your operating system. (It is just a sandboxing technology)
	On OS X and Windows, Docker uses a single, small virtual machine to run all the containers. (On Linux it runs natively)
	
Ch2:
	detached/interactive containers (daemon / cli-bound)
	docker run --detach --name web nginx:latest
	docker run -d --name mailer
	
	docker run --interactive --tty --link web:web --name web_test busybox:latest /bin/shi

docker run --name mantis-postgres -e POSTGRES_PASSWORD=QAZxsw123 -e POSTGRES_USER=root -d postgres

docker run -p 80:80 \
    -e 'PGADMIN_DEFAULT_EMAIL=petascalr@gmail.com' \
    -e 'PGADMIN_DEFAULT_PASSWORD=QAZxsw123' \
    -e 'PGADMIN_CONFIG_ENHANCED_COOKIE_PROTECTION=True' \
    -e 'PGADMIN_CONFIG_LOGIN_BANNER="Authorised users only!"' \
    -e 'PGADMIN_CONFIG_CONSOLE_LOG_LEVEL=10' \
    -d dpage/pgadmin4
    
docker inspect <containerID>

===== Kubernetes =====

02. Introduction
	- kubectl sends commands to the kube-apiserver (REST). The same commands could be sent using curl.
	- Configuration is kept in etcd (a B+Tree config map).
	
	
03. Kubernetes running modes
	- Private cloud, created with kubeadmin
	- Private minikube, for development purposes only.
	- Using a public cloud provider like Azure, GCP (Google Kubernetes Compute) or AWS (Amazon Elastic Kubernetes Service).
	
04. Understanding Kubernetes API and commands.
	- In kubernetes, API access is regulated by using RBAC (Role based access control)
	- In RBAC, user accounts are identified as a set of certificates associated to a name, defined in ~/.kube/config
	- K8s does not support external users, like AD or LDAP, just the users defined locally, with permissions from ~/.kube/config.
	- Use 'kubectl auth can-i --help' to see what you can do with your user.
	- K8s services also function as a Load Balancer.
	- By default, each pod has it own non-persistent storage. Now Persistent Volume (PV) comes into play, 
		that allows persistent storage attached to pods. Pods are connected to PVs by PVCs (persisten volume claim).
	- curl http://localhost:8001/apis
	- kubectl explain
	- kubectl can support bash completion using tab-tab.
	- Knowing how to create the yaml specifications: kubectl explain pod.spec, tells you how to populate the pod specification.
	- kube-api-server uses TLS. Kubectl reads ~/kube/config and takes the certificates from it. kubectl talks directly to api-server.
	- When using curl, we talk to kube-proxy, that in turn talks to kube-apiserver.
	- etcdctl can be used to interrogate the etcd B+Tree map of configs.

05. Pods and Deployments
	- Namespaces are a linux kernel feature that is leveraged up to Kubernetes level.
	- Namespaces implement strict resource separation. eg: kube-system & default namespace.
	- resource limitation through quota can be implemented at a namespace level also.
	- Use namespaces to separate different customer environments within one Kubernetes cluster.
	- Four namespaces are defined when a cluster is created:
		- default: this is where are resources are created.
		- kube-node-lease: an administrative ns where node lease information is stored. - may be empty or non-existent.
		- kube-public: a ns that is world-readable. Often empty. Used for generic information.
		- kube-system: contains all the infrastructure pods.
	- In the etcd DB all the info is stored in Json format. 
	- Deployments provide Replication and Upgrades for Pods.
		- Replication takes care of the scalability of the Pods.
		- Replication is not handled directly by the Deployment but rather by a ReplicaSet.
		- A ReplicaSet is part of the deployment, but it also exists as a separate object.
		- The ReplicaSet manages the Deployment and the Deployment manages the ReplicaSet.
	
	- Labels can be set on different Kubernetes objects. In many cases, labels connect object together (like a service to a deployment).
		- kubectl get deploy --show-labels
		- Setting a new label: kubectl label deployments.apps mynginx state=demo
		- kubectl get deployments --selector state=demo ;; prints only those deployments with label demo.
	- Managing rolling updates: If you update the version of a image from a deployment with rs=3, it will first create another rs with 3 pods keeping the old 3 present,
		and when the new are created, it will start deleting the old pods. We have 2 upgrade properties:
			- maxSurge: specifies how many additional pods you can have during a rolling update.
			- maxUnavaiable: Lets say it is defined to 1, you are guaranteed to have at least 2 pods running at all times. (rs is 3).
			- kubectl explain deployments.spec.strategy.rollingUpdate
	
	Init containers: If a pod has 2 containers, one of them can be used as an init container. Used to prepare something before the main App is started.
		- they run to completion. Unless they finish, the main container won't start.

	StatefulSets: are like deployments, but provide guarantees about the ordering and uniqueness of Pods.
		- they maintain a unique identity for each Pod, wich makes Pods non-interchangeable.
		- are valuable if your app has one of the following reqs:
			- unique network identifiers or stable persistent storage;
			- ordered deployment and scaling or ordered automated rolling updates;
		- they have some limitations. must be used only when really necessary.
		- StatefulSets must be scaled down to 0 before deletion (not needed for deployments).

K8s commands to get information about the running cluster:
	minikube version
	minikube start (as non root)

	kubectl version
	kubectl cluster-info
	kubectl config view 		;; prints the config from ~/.kube/config
	kubectl get nodes

	kubectl api-resources
	kubectl api-versions
	
	kubectl get pods --show-labels
	kubectl get pods -l 'environment in (production),tier in (frontend)' ;; filter pods by labels
	
	kubectl get ns ;; returns all namespaces
	kubectl get all --all-namespaces
	kubectl create ns dev
	kubectl describe ns dev
	kubectl get ns dev -o yaml ;; gets the yaml used to create the namespace.

	kubectl describe pods ; see what containers are inside each pod
	kubectl get deployments
	kubectl get rs ;; gets the ReplicaSets created by a deployment.
	kubectl rollout status deployment/nginx-deployment
	kubectl describe deployments
	kubectl get service --all-namespaces
	kubectl get ingress --all-namespaces
	kubectl describe ingress ptc-default-olptc-ingress -n ptc-default

	kubectl get nodes --help
	
	kubectl get all -n namespace
	kubectl get all --selector app=mynginx ;; selects only objects with label app=mynginx
	kubectl get deploy --show-labels

Rollout history:
		kubectl rollout history deployment ;; see the rollout history of all deployments.
		kubectl rollout history deploy rolling-nginx --revision=2 ;; get more details about a given old revision of a deployment.
		kubectl rollout undo deploy rolling-nginx --to-revision=1 ;; brings back an old revision.
		
Curl commands to get information:
	kubectl proxy --port=8001 & ;; starts the kubectl proxy 
	curl http://localhost:8001
	curl http://localhost:8001/api/v1/namespaces/default/pods
	
Kubernetes 'auth can-i' command:
	kubectl auth can-i create deployments
	kubectl auth can-i create pods --as linda --namespace apps
	
Commands to alter the running cluster:
	kubectl create -f obj.yaml ;; creates the object defined in obj.yaml.
	kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1
	kubectl edit deploy X
	kubectl create deploy --dry-run --image=nginx --output=yaml ;; generates the yaml deployment corresponding to the imperative command.
	kubectl scale deploy mynginx --replicas=3
	
Delete K8s resources:
	kubectl delete namespace <namespace>
	kubectl delete deploy <deployment>
	kubectl drain <nodeName> ;; remove all pods for that node

Etcd manipulation:
	etcdctl -h
	
	
	
# A Pod is a Kubernetes abstraction that represents a group of one or more application containers (such as Docker or rkt), 
# and some shared resources for those containers
Every node has:
	1. a kubelet, communicating between the node and master.
	2. a container runtime, like docker.
	
Runs the GO template generator and replaces all go code with actual code:
	helm install --dry-run --debug ./mychart
	
	nci_helm_manager develop
	nci_helm_manager release
	nci_helm_version_manager develop
	nci_helm_version_manager run
	


# execute commands inside the POD:
kubectl exec $POD_NAME env
kubectl exec -ti $POD_NAME bash ;; execute the bash inside the POD.

===== Helm =====

