General knowledge:
	- The EJB specification is a subset of the Java EE specification
	- Spring is a replacement for EJB.
	- The EJB specification intends to provide a standard way to implement the server-side (also called "back-end") 'business' software typically found in enterprise applications (as opposed to 'front-end' user interface software).
	

Integer types:
	- all of them are signed (unsigned types do not exist, except char (16 bits) type)
	- decimal, binary, and hex are possible: 0x1f, 0b1010101, 43433434; binary literals can be split in groups by four by underscore: 0b1101_0010_1111
	- integers are by default int, unless they end with l or L when they become longs. eg: 0x234aL, 433l, 455L, etc
	- overflow and underflow never produces. numbers just wrap around. (the compiler does not warn about these)
	- division by zero or module by zero throw: ArithmeticException.
	- convert String to int: Integer.parseInt(); // same for all other types.
	
Float types:
	- floating point numbers are double by default. they become float if they are suffixed with f.
	1.2345E02 (1.23 * 10^2)
	- floating point operations never throw exceptions. (not even for division by zero, underflow, overflow)
	
The java compiler complains when you attempt a narrowing conversion (byte b = 13000;) they can only be done with an explicit cast.
	synchronized: when used on an object instance, it holds that lock. It can be used as a method modifier also.
	
Exceptions:
	- catch (Exc1 | Exc2 e) {} // allows multiple exceptions to be caught in the same statement.
	- all exceptions extend Throwable (it is a class, not an interface)
	- the only way the code in finally is not executed is to System.exit();
	- try with cleanup: try (InputStream is = new FileInputStream("gig.txt")) {} // no need for finally, the compiler cleans automatically
	Sample exceptions: AssertionError (from assert(), if assertions are enabled)
		Checked: Derive from Exception (Throwable). Are thrown by the user. (IOException, FileNotFoundException, etc)Must be specified in the throws clause in the method signature. Application can recover from them (not necessarily quit)
		Unchecked: Derive from "Error" or "RuntimeException". Examples: NullPointerException, AssertionError, OutOfMemoryError, etc (they cannot be predicted). Recovery from them is usually impossible, so the program quits.

Assertions: by default they are disabled.
	to enable, run with: java -ea MyProgram (only in user classes). java -esa MyProgram (enable in system classes).
	
	
instanceof : some sort of dynamic_cast (it just returns true/false. it never throws)
instanceof always evaluates to false if its left-hand operand is null.
assert : like in C, only that it throws exception AssertionError.

Methods specifier:
	- abstract: declares the method as abstract (must be overridden). Containing class must also be declared abstract. It has no body (like a pure virtual method in C++). Any class with one or more abstract methods must be declared abstract
	- final : a final method cannot be overridden (usefull for optimizations)
	- native: implementation is done in another language (like C). It contains no implementation (like abstract). native methods are used to interface Java code to existing libraries written in C or C++
	- strictfp: make JVM perform floating point operations in strict mode, i.e. either 32 or 64 bits. (Does not take any advantage of the FP HW available on the platform) (Using strictfp guarantees that results of floating-point calculations are identical on all platforms)
	- synchronized: (can be either static or normal methods also). The synchronized modifier makes a method threadsafe. Before a thread can invoke a synchronized method, it must obtain a lock on the method’s class (for static methods) or on the relevant instance of the class (for non-static methods). This prevents two threads from executing the method at the same time.
	
	Varargs methods:
	(1) public int Max1(int first, int... rest) is similar to: (2) public int Max2(int first, int[] rest)
	Calling examples:
		Max1(5); Max1(5, 7); Max1(4,6,7,8,4);; Max1(4, new int[]{4,2,1}); // can be called both ways: with varargs or with array
		Max2(2, new int[]{4,6,3,2,1}); // only this is a valid call for this signature

Lambda expressions:
	Runnable r = () -> {System.out.println("Hello World");}
	r.run();
	
Arrays:
	- arrays can be widened in Java (array covariance). String[] arrStrings; Object[] arrObjs = arrStrings; (works only for arrays of reference types). if type mismatch => ArrayStoreException.
	byte[] byteArray = new byte[32];
	byte[][] byteMatr = new byte[32][32];
	
	// These three lines declare fields of the same array type:
	public String[][] aas1; // Preferred Java syntax
	public String aas2[][]; // C syntax
	
	public String[] aas3[]; // Confusing hybrid syntax
	
	String[] greetings = new String[] { "Hello", "Hi", "Howdy" };
	int[] smallPrimes = new int[] { 2, 3, 5, 7, 11, 13, 17, 19, };
	String response = askQuestion("Do you want to quit?", new String[] {"Yes", "No"});

	int[] powersOfTwo = {1, 2, 4, 8, 16, 32, 64, 128};	// correct, only at declaration time;
	Point[] points = { circle1.getCenterPoint(), circle2.getCenterPoint() }; // also correct, arrays are initialized at run-time, not compile-time.
	- as every class in Java, it inherits from java.lang.Object, that implements Clonable and Serializable interfaces
	- ArrayIndexOutOfBoundsException.
	java.System.Arrays.binarySearch(), equals(), sort(), 
	
	int[] data = { 1, 2, 3 };
	int[] copy = (int[]) data.clone(); // because all arrays implement the Cloneable interface (from java.lang.Object)
	
Boxing and unboxing conversions (autoboxing)
	Integer i = 0; // int literal 0 boxed to an Integer object
	Number n = 0.0f; // float literal boxed to Float and widened to Number
	Integer i = 1; // this is a boxing conversion
	int j = i; // i is unboxed here
	i++; // i is unboxed, incremented, and then boxed up again
	Integer k = i+2; // i is unboxed and the sum is boxed up again
	i = null;
	j = i; // unboxing here throws a NullPointerException
	
types from java.lang can be used without importing them
	- java.net.*
	- java.io.*
	- java.util.*
Importing static members from a class:
	- import static java.lang.System.out;
	- import static java.lang.Math.*; (after this we can call sqrt(abs(sign(x))));
	
If a Java file contains a public class, the name of the file must be the same as the name of the class.
A .java source file may have more than one classes defined in them, but at least one class must have the same name as the source filename.

In order to tell the java interpreter to look for .class files in other directories apart from the current directory, tell him this by using the -classpath option (or -cp), or the CLASSPATH environment variable.

Execute jar archives (containing a main class, and all the required classes to run)
java -jar Program.jar

Classes and interfaces
	- a final class cannot be extended.
	- a strictfp class is as if declaring all of its methods strictfp.
	- starting with Java 8, interfaces are allowed to define default methods (methods with implementation), that classes implementing the interface are not forced to override the default methods.
	- transient modifier: This modifier specifies that a field is not part of the persistent state of an object and that it need not be serialized along with the rest of the object.
	- volatile modifier: a volatile modifier may not be cached by the compiler in a register, because it is used by multiple threads. (no optimizations on it)
	- every class contains at least one constructor - the default ctor automatically generated by the compiler. that performs no initialization and takes no parameters
	- class fields (both static and non static) are automatically initialized by the compiler to the default values. Stack variables are not (compile error, used without initialization).

	- static initializer: a bloc of code in a class that declares static fields. it is called before any constructor, and its purpose is to initialize complex static data members of that class.
	- instance initializers: Instance initializers can initialize arrays or other fields that require complex initialization. They are sometimes useful because they locate the initialization code right next to the field, instead of separating into a constructor (rarely used).
	- calling other ctor from the same class: this(x, y) - must be first statement in a ctor
	- calling ctor of superclass: super(x, y); - must be first statement in our ctor.
	- if we declare one ctor for a class, the default one will NOT be generated anymore.
	- declaring a private ctor makes a class unable to be instantiated (like java.lang.Math, or java.lang.System).
	- covarian return types are also supported in Java, just like in C++.
	- invoking an overridden method from our class: super.func1(). Casting this to the superclass DOES NOT WORK.
	- protected access specifier for fields/methods: field is accessible to all classes in the same packages, plus to all subclasses.
	- package access specifier (the default one): field is only accessible to classes in the same package (more restrictive than the protected acc specifier)

	Java interfaces:
		- Cloneable: adds: clone() method
		- Comparable<T>: adds compareTo(T o) method
		- Serializable: after implementing this interface, objects can be transferred over sockets and stuff.

- A cast in Java that does not succeed throws ClassCastException;
- In addition to converting an array to an object, an array can be converted to another type of array if the “base types” of the two arrays are reference types that can themselves be converted.
	String[] strings = new String[] { "hi", "there" };
	CharSequence[] sequences = strings;
	strings = (String[]) sequences;

Interfaces:
- All members of an interface are implicitly public (otherwise we get compile error if we declare them protected/private)
- Interfaces may not declare any instance fields. They can only declare static final fields.
- As of Java8, interfaces are allowed to have static methods.
- A Marker interface is an interface that defines no functions. Serializable is such an interface.

Compiling:
Create a JAR out of multiple .class files:
	$> jar -cfv Application.jar ./*.class

Compile a .java file with a dependency on a JAR:
	$> javac -classpath ".:/home/path/mail.jar;/home/path/servlet.jar" MyJavaFile.java
	or:
	$> CLASSPATH=".:/home/path/mail.jar;/home/path/servlet.jar"
	$> javac MyJavaFile.java
	
Generics:
	- type T MUST always be a reference type (POD types not allowed)
	- diamond syntax: List<CenteredCircle> shapes = new ArrayList<>();
	- type erasure: Java generics work like C++ templates. The type T is only visible at compile time, so, this is perfectly Legal in Java:
		List listOfNames = getListOfNames();
		List<String> stringList = (List<String>)listOfNames;
		
		// Won't compile (at compile time they look different, but at bytecode level, they are the same). After type erasue, both methods become "int totalOrders(Map);"
		interface OrderCounter {
			int totalOrders(Map<String, List<String>> orders); 	// Name maps to list of order numbers
			int totalOrders(Map<String, Integer> orders);		// Name maps to total orders made so far
		}
	- Wildcards:
		ArrayList<?> listOfElems = getList();
		Object o = (Object)listOfElems.get(0);
		
	PECS principle (Producer Extends, Consumer Super)
		List<? extends Object> = getList(); // any list of objects that extend Object.
		List<? super String> = getList(); //any list of objects that String derives from.
		- when you use <? extends T>, you are restricted to use only the covariant (T producing) methods of the class;
		- when you use <? super T>, you are restricted to use only the contravariant (T consuming) methods of the class.
		
		
Annotations:
	from jdk: @Override, @Deprecated, and @SuppressWarnings. Since Java7: @SafeVarargs, @FunctionalInterface

Threads:
	- synchronized can be applied to a method or to code blocks
	- synchronized can’t appear on a method declaration in an interface.
	- synchronize uses a object monitor (mutex) - one mutex per Object
	- Java’s locks are reentrant. This means that if a thread holding a monitor encounters a synchronized block for the same monitor, it can enter the block
	- wait() & notify() are member functions of Object. wait() and notify() must be used inside a synchronized method or block.
	- sleep() & start() & run() are from Thread.
	
Runtime.exec("ls -l") : spawns a new process from java.
System.getenv() : returns the environment variables.

Java Collections:
	- Java collections only work on reference types, not POD types (not like in C++)
	- java.util.Collections contains only static methods (algorithms) that operate on all collection types.
	
	- Interfaces: 
		java.util.Collection is the root interface of all collections framework. It contains methods like add(), remove(), clear()
		java.util.List, java.util.
		Collection : interface
			List
			Set
			Map
		
Strings:
	legal Java: System.out.println("Dog".length());
	
Ch6: Java’s Approach to Memory and Concurrency
	- JVM uses Mark & Sweep (1. Mark all objects as dead; 2. Iterate all GC roots and mark all reachable objects as alive. Iterate again, and remove all dead objects).
	- A true memory leak cannot occur in Java. However, a object may be kept alive longer than necessary.
	- GC works by STW ( stop the world), i.e. it collects the garbage while all application threads paused.
	- (WGH) weak generational hypothesis: Java objects have a small number of possible life expectancies (generations)
	- Evacuating GC: alive objects are moved to a different area of the heap (having in mind that most objects are dead), and the dead objects space is reallocated.
	- If the object has a finalize() method, it will be called before the object is GCed. The finalize() method can ressurect the object (be putting the this reference somewhere outside.). In this case the object will not be GCed anymore. The finalize() method is called only once, even if the object is resurrected.
	- The finalize() mechanism is broken by design. The platform can make no guarantees about when (or even whether) a finalizer will be invoked or in what order finalizers will be invoked. TO BE AVOIDED.
	- To ensure that certain actions are taken before the VM exits, Java provides Runtime::addShutdownHook().
	Threading:
		- Thread t = new Thread(() -> {System.out.println("Hello Thread");}); t.start(); // the lambda maps to the Runnable interface.
		- Threads lifecycle: Thread.State { NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED }
		- Object.wait(), notify(), notifyAll(). Thread.run(), start(). wait() and notify() must be used inside a synchronized method or block, because of the temporary relinquishing of locks that is required for them to work. properly.
	
Ch8: Working with the Java Collections
	- Interfaces: Map, SortedMap, Collection, List, Set, SortedSet
	- Map<K,V> (root interface): key, value pair;
	- Collection (mother interface for List & Set)
	- List: a collection with ordered elements (may contain duplicates)
	- Set: a collection with no duplicates.
	- All of the collection and map implementation classes provided in the Java Collections Framework implement Clonable and Serializable interfaces.
	- Iterating:
		- the 'foreach' loop works on any class that implements java.lang.Iterable interface.
		for(Iterator<String> i = c.iterator(); i.hasNext();) { System.out.println(i.next()); }.
		
	- testing if a collection has random access (implements interface RandomAccess): if ( c instanceof RandomAccess ) {  }.
	
	
	Common collections:
		- interface Set<E> extends Collection<E>
			- class HashSet<E> implements Set<E>
			- class TreeSet<E> implements SortedSet<E> (who in turn implements Set<T>)

		- interface Map<K, V> (does not extend the Collection interface). Methods: put(K, V), get(K), remove(K)
			An important aspect of Map is that it can be viewed as a "collective view". Its Keys as a Set, Its values as a Collection. And its <K,V> pairs as a Set of Map.Entry
				- class TreeMap
				- class HashMap
				- class 
		
		- Queue<E> extends Collection<E>
	java.util.Collections static class contains static utility classes that work on collections (sort, search, etc)
	
	- Except for the legacy classes Vector and Hashtable, the collection implementations in java.util do not have synchronized methods and are not protected against concurrent access by multiple threads.
		- Synchronized collection can be achived with wrapper classes:
			List<String> list = Collections.synchronizedList(new ArrayList<String>()); 
			Set<Integer> set = Collections.synchronizedSet(new HashSet<Integer>());
			Map<String, Integer> map = Collections.synchronizedMap(new HashMap<String,Integer>());
		- Read only wrappers for collections (usefull when you want to pass them to a method as read-only), if modified throws OperationNotSupportedException:
			List<Integer> primes = new ArrayList<Integer>(); List<Integer> readonly = Collections.unmodifiableList(primes);
			
		- CopyOnWrite-like collections (CopyOnWriteArrayList, CopyOnWriteTreeSet, etc): used when the read operations are prevalent (over the write operations). Any time the user does a write operation, the entire collection is copied, and the iterator works on the newly copied collection. When there are no longer any iterators on the old collection, it is deleted.
		
	- Other usefull static methods: Collections.copy(list1, list2);
		Collections.fill(list, o); // Fill list with Object o
		Collections.max(c); / Collections.min(c); / Collections.reverse(list); / Collections.shuffle(list);
		Collections.singleton() / singletonList(), singletonMap() returns immutable collections that contain a single element.
		List<Integer> tenzeros = Collections.nCopies(10, 0); // returns an immutable List that contains a specified number of copies of a single specified object
		
	Method references: since Java8 a method can be used in place of a lambda, like this MyClass::toString ( is equivalent to (MyClass mc) -> { mc.toString(); })
	
	Lambda expressions used with collections:
		- map() : converts one collection to another collection of a different type.
		- filter(): some sort of select (returns a subset of the collection based on some conditions). (makes use of the java.util.functional.Predicate interface)
			        List<String> names = Arrays.asList("Ion", "Costel");
					List<String> result = names.stream().filter((String s) -> { return s.startsWith("I"); }).collect(Collectors.toList());
					Predicates can be combined: Predicate<String> p = s -> s.equalsIgnoreCase(search);
												Predicate<String> combined = p.or(s -> s.equals("leopard"));
												String pride = cats.stream().filter(combined).collect(Collectors.joining(",  "));
												
		- map() (makes use of the Function<U, R> interface): converts a collection into another collection:
			List<Integer> namesLength = cats.stream().map(String::length).collect(Collectors.toList());
		
		- forEach (contrary to map, this mutates the original collection, uses the Consumer<T> interface)
			List<String> pets = Arrays.asList("dog", "cat", "fish", "iguana", "ferret");
			pets.stream().forEach(System.out::println);

		- reduce(): it is a sort of accumulate. Uses BinaryOperator<T> and applies it succesively to all elements, keeping the result.
			double sumPrimes = ((double)Stream.of(2, 3, 5, 7, 11, 13, 17, 19, 23).reduce(0, (x, y) -> {return x + y;}));
	
	Functional interfaces:
		- Function<T, R> { R apply(T t); }
		- Consumer<T> { void accept(T t); }
		- Predicate<T> { bool test(T t); }
		- Supplier<T> { T get(); }
		
Ch9: Handling common data formats
	- String is immutable.
	- StringBuilder for constructing strings.
	- Regexp in java: classes: java.util.regex.Pattern & Matcher.
	- java.math.BigDecimal for representing float numbers without rounding.
	
Ch10: File Handling and IO.
	- File class
	- Streams: abstract classes: InputStream, OutputStream (System.in & System.out are instances of these streams)
	- Reader & Writer classes: used for characters (not bytes as Streams). FileReade/Writer, BufferedReader/Writer; they accept Input/Output streams.
	- Streams/Readers implement the AutoCloseable interface in order to work with try-with-resources (TWR), that automatically closes them when they get out of scope. (like C#'s using).
	- NIO.2 API since Java7, in java.nio.file; Classes Files (static methods) and Path/Paths, FileSystem/FileSystems

Ch11: Classloading, Reflection and Method Handles.
	- Class<?> c = o.getClass(); c = int.class; c = String.class; c = byte[].class.
	- Java classes can be loaded from a remote location into the JVM with URLClassLoader.
	- Class<?> jdbcClz = Class.forName("oracle.jdbc.driver.OracleDriver"); loads a class by name from the classpath.
	- Instances can be constructed reflexively (by using Class::newInstance() or another constructor).
	- Methods can be invoked reflectively with Method.invoke().
	
	
	

Sample interfaces in Java: Collection, Map, Set, List
Sample abstract classes: InputStream, OutputStream
final classes: java.nio.file.Files;
Sample static classes: Math, Collections, Arrays
Sample exceptions: 	Unchecked: NullPointerException, AssertionError, OutOfMemoryError (RuntimeError). 
					Checked: IOException, FileNotFoundException

Important things to reconsider:
	- Java Collections & Streams
	- Generics
	- NIO.2 API