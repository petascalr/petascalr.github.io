General
	val types in scala cannot be reassigned. (it does not compile - SSA form)
	type of val types is inferred but it can also be specified: val x : Int = 1+2
	variables are like vals, but they can be reassigned. var x : Int = 34+2
	
Functions: are expressions that take parameters
	(x: Int) => x + 1
	
Methods:
	def add(x: Int, y: Int): Int = x + y
	println(add(1, 2)) // 3

	def addThenMultiply(x: Int, y: Int)(multiplier: Int): Int = (x + y) * multiplier
	println(addThenMultiply(1, 2)(3)) // 9
	
	def name: String = System.getProperty("user.name")
	println("Hello, " + name + "!")
	
	def getSquareString(input: Double): String = {
		val square = input * input
		square.toString // The last expression in the body is the method’s return value. (Scala does have a return keyword, but it’s rarely used.)
	}

Classes:
	class Greeter(prefix: String, suffix: String) {
	  def greet(name: String): Unit = // Unit is similar to void return type in java and C
		println(prefix + name + suffix)
	}
	
Case classes: immutable and comparable by value.
Tuples: similar to case classes, but they define names for each tuple element.

	* Every user-defined type in Scala is a subtype of AnyRef. Users cannot define value types. AnyRef corresponds to java.lang.Object.
	* 'Nothing' is a subtype of all types, also called the bottom type. There is no value that has type Nothing. A common use is to signal non-termination such as a thrown exception, program exit, or an infinite loop
	* 'Null' is a subtype of all reference types (i.e. any subtype of AnyRef). It has a single value identified by the keyword literal null. Null is provided mostly for interoperability with other JVM languages and should almost never be used in Scala code.

* Classes
	- class fields are by default public. they can be made private with the private keyword. Setter methods can be defined for member fields, with the '_' suffix.
	- classes and traits can be declared with sealed, which means that all subtypes CAN/MUST be declared in the same file (so they are known upfront).
	
* Traits
	- Traits are used to share interfaces and fields between classes. They are similar to Java 8’s interfaces. Classes and objects can extend traits but traits cannot be instantiated and therefore have no parameters.
	- Mixins are traits which are used to compose a class.

* Higher-order Functions
	- Are functions that take as parameter another function.

* Currying of functions: def curry(a: Double, b: Double)(c: Double): Double = ((a+b)/c)
	val func1 = (x: Int, y: Int) => (z: Int) => (x+y)*z. 
	val func2 = func1(3,4)
	
* Case classes
	- are used to hold immutable data, and they are compared by structure, not by reference.

* Pattern matching: a more advanced form of switch in Java. Can also be used with case classes.
	- Can also be used with Pattern Guards, to make the specialization more specific, just add if (cond) after the case instruction.

* Singleton Objects: cannot be instantiated, and they behave as if they were instantiated with val with the same name as the declaration name.
	- like vals, singleton objects can be defined as members of a trait or class, though this is atypical.
	- Companions: A class and its companion object, if any, must be defined in the same source file.
	- static is not a keyword in Scala. Instead, all members that would be static, including classes, should go in a singleton object.
	- In the context of private, a class and its companion are friends.
	- Methods, including vars and vals, defined directly in a singleton object also have a static method defined in the companion class, called a static forwarder

* Regexps:
	- Any string can be converted to a regular expression using the .r method: val numberPattern: Regex = "[0-9]".r
	
* Extractor objects: 
	- contrary to a ctor, that takes params and stores them as the object state, the extractor object returns those params from the object. It is used with pattern matching. Function unapply().

* Generics/Variances:
	- Variance is the correlation of subtyping relationships of complex types and the subtyping relationships of their component types.

* Operator "::" : prepends an element to a list of elements.

* Inner classes in scala belong to the instance, not to the class. graph1.Node is different from graph2.Node, even if graph1 and graph2 are instances of the same Graph class, that contains the Node inner class. (In Scala inner classes are bound to the outer object).

* Abstract type members: type T, can be declared inside abstract classes or traits (types that must be sub-classed). Abstract type params can be turned into generic class params and vice-versa.

* Compound types: def cloneAndReset(obj: Cloneable with Resetable): Cloneable = {}. obj must both implement Cloneable and Resetable.

=================================================================
Scala in depth:
Ch1: Intro
	- Scala defines 3 variable types on the left hand side: val, var, lazy val.
	- Type inference: the compiler deduces the type of an expression automatically: val X=5; (x is automatically an Int).
	- Operator notation. Scala treats methods as operators. A parameter-less method can be treated as a postfix operator. A method with 1 arg can be treated as an infix op.
	- Java in Scala: Java classes=> Scala classes. Java interfaces => Scala abstract traits.
	
Ch2: The core rules
	- REPL: experiment driven programming (Interactive Scala Shell).
	- REPL: companion object, or :paste command, used to compile blocks of code at once in REPL. (that has cross dependencies in it).
	- a scala build tool can be integrated with JRebel to dynamically load classes inside REPL as they are modified.
	- imperative vs expression-oriented programming.
	- var: mutable reference. val: immutable reference. All method params are immutable references.
	- You can have an immutable reference to a mutable object and vice versa.
	- Scala collection libraries have parallel hierarchies, for mutable/immutable.
	- primitive types are subtypes of scala.AnyVal. Normal objects are subclasses of scala.AnyRef (can be considered an alias for java.lang.Object). hashCode & equals are defined in AnyRef, ## & == can be used on both AnyRef & AnyVal.
	
	class Point2(var x: Int, var y: Int) {
		def move(mx: Int, my: Int) : Unit = {
		x = x + mx
		y = y + my
		}
		override def hashCode(): Int = y + (31*x)
	}
	
	- use None instead of null. Scala provides Option for this purpose, that provides None/Some.
	
Ch3: Modicum of style
	- In Scala, contrary to Java, newlines influence how the parser parses the scala code.
	- By using named-parameters, you expose your function parameters names in your API. Chaning their names in the API will break your clients.
	
==================================================================	
Programming in Scala

## Ch1: Introduction & Ch2: First Steps
	- a functional language has functions as first-class values. Functions can be stored in variables, passed as arguments to other functions, returned from functions.
	- Another idea of functional programming: functions should map inputs to outputs, not change data inside the function. (Functions should not have side effects). They should communicate to their environment just by taking arguments and returning results. These methods are called "referentially transparent", which means that for any given input, these function calls can be replaced with their result, without changing the program behavior.
	- Scala is a statically-typed language that supports type inference.
	- scala has a very strong type inference system, that lets you ommit duplicated code like this:
	val x: HashMap[Int, String] = new HashMap[Int, String]();
	- for recursive functions you must explicitly specify the return type. (it cannot be inferred).
	- if the functions consists of only one statement, you can leave off the curly braces.
	- imperative vs functional style.
	- for expressions: for (arg <- args) {}; for (i <- 1 to 10) {}

## Ch 3: Next Steps in Scala
	- Scala arrays: val x: Array[String] = new Array[String](3) are indexed by (), not [] like in Java.
	- if a method takes only 1 param, you can call it without the dot and parenthesis, like: 1 to 10; to is a method taking one param of type int.
	- scala does not have operator overloading in the traditional sense, but operators like +, -, etc are methods in class Int that take one parameter of type Int - All operators are method calls in Scala.
	- Accesing an array elem in scala is just a method call like any other. This call gets converted to:
		x(i) gets converted to x.apply(i); Assigning to an array elem gets converted like this: x(i) = "Hello"; x.update(i, "Hello")
	- another array initialiation: val arr = Array(3, 4, 5); this way, you are not calling the ctor of array, but a factory method called apply() from Array object.
	- ::: operator concatenates 2 lists.
	- :: operator prepends an elem to a list. 1 :: list;
	- Nil represents an empty list. val thrill = "a" :: "b" :: Nil
	- val moviesSet = mutable.Set("Wolf", "Hitch!"); moviesSet += "Shrek!"
	- Scala arrays are mutable, Lists are immutable. Sets/Maps can be either mutable and immutable. By default Sets/Map are immutable, unless imported mutable and inited like val x = mutable.Set(1,2,3)
	- if the code contains vars it is probably imperative. functional code usually contains vals only.
	- If a function returns Unit, it is usually not functional in style. (it has side effects)
	- every collection contains a .mkString(separator) method, that returns the list of objects in the collection separated by the passed string.
	
## Ch4: Classes and Objects
	- in Scala fields are by default public.
	- method parameters are by default vals, not vars, therefore cannot be reassigned inside the method.
	- a class and its companion object, if any, must be declared in the same source and they can access each other's private members.
	- String interpolation: s"Hello $name, you are ${3+5} years old!". println(f"You are %s years", numYears); raw interpolation: println(raw"No\\\\\\escapes!"); prints "No\\\\\\escapes!" without escaping.
	- scala postfix & prefix operators are always unary. Prefix unary operator are declared like this def unary_-(), i.e. with the method name containing this prefix "unary_". Postfix operator is any method call that has no params, like s toString.
	- objects can be compared for equality with the ==, contrary to java. ("he" + "llo") == "hello" is true in scala.
	
## Ch6 Functional Objects
	- functional objects: objects that do not have any functional state.
	- methods or ctors can impose restrictions on params with require(p != 0). If broken, IllegalArgumentException is thrown.
	- Auxiliary ctors: ctors other than the primary one: def this(n: Int) = this(n, 1) // auxiliary constructor. Every aux ctor must first invoke another ctor, not necessarily the primary one. Only the primary ctor can invoke the ctor from a superclass.
	- you can define any symbol with any name between ``. Like val `def` = 3;
	- Implicit conversions: implicit def intToRational(x: Int) = new Rational(x).

## Ch7: Built-In Control Structures (if, while for try match and function calls )
	- almost all scala's control structures return a value. while and do-while does not return a value, and because of this they are usually left out of functional languages.
	- for (i <- 1 to 10) {1-10}; for (i <- 1 until 10) {1-9}; 
	- for with filter: for (file <- filesHere if file.getName.endsWith(".scala")) println(file)
	- producing a new collection: def scalaFiles = for { file <- filesHere if file.getName.endsWith(".scala") } yield file
